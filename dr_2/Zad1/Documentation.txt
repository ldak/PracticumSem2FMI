Small string optimisation постигаме като запазваме в една структура всички данни които ни трябват за big string
(char pointer, length, capacity) и в друга структура данните които ни трябват за small string
(които в момента са статичен масив с големината на всички данни в структурата за big string).
Слагаме 2те структури в един union, за да не използаме излишна памет.
Като потребителят създаде обект от тип MyString, запазваме стринг, който е подал в масива за small string,
ако големината на стринга е равна на големината на масива за small string -1 (в последния байт пазим терминиращата нула),
За флаг дали използваме big или small string използваме проверката дали big.length > big.capacity || big.capacity = 0,
Сигурни сме, че тези случаи никога не се достигат, ако използваме big string, а тези случаи се достигат при използване на small string,
защото, ако стрингът ни е достатъчно малък, че да се събере само в пойнтъра и дължината,
капцитетът не се променя, а дефоултната му стойност е 0. Ако е толкова голям, че да се използват и битовете на капацитета,
последният байт на дължината ще е различен от 0, а последният байт на капацитета ще е 0(там се съдържа или терминиращата нула или нищо),
а тъй като сме в little endian, последният байт е най-значим.
Друга важна забележка е, че функцията, връщаща дължината на стринга работи в зависимост от това дали
използваме SSO. Когато стрингът ни изполва SSO всеки път изчисляваме дължината с strlen, което в общия
случай е лоша практика, но тъй като дължината на стринга е винаги не повече от 23, то сложнстта за намиране
на дължината спада от линейна на константна. В случаите, когато използваме голям стринг, за който алокираме
памет просто връщаме стойността на length.